<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript继承]]></title>
    <url>%2F2019%2F05%2F16%2Fjs%2F</url>
    <content type="text"><![CDATA[JavaScript 继承两种继承方式，Javascript仅支持其一： 接口继承 – 方法签名 12345678910111213141516//PHP中的接口继承interface InterA &#123; const TITLE = "PHP接口继承"; public function showInfo($a, $b);&#125;interface InterB &#123; public static function readMe();&#125;class Student implements InterA,InterB &#123; public function showInfo($name, $age) &#123; echo "&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;"; &#125; public static function readMe()&#123; echo self::TITLE; &#125;&#125; 实现继承 – 实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承 ECMAScript中只支持实现继承，继承方式主要依赖原型链 1234567891011121314151617function SuperType() &#123; this.property = true&#125;function SubType() &#123; this.subproperty = false&#125;//向SuperType构造函数的 prototype原型中添加方法属性SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;//SubType构造函数的 prototype原型指针 指向 SuperType类型的实例SubType.prototype = new SuperType()SubType.prototype.getSubValue = function() &#123; return this.subproperty&#125;var instance.getSuperValue()alert(instance.getSuperValue()) //true 上例中，SubType构造函数的prototype原型被重写指向SuperType构造函数的一个实例，其中之前SubType构造函数原型中的默认constructor属性被重写，instance.constructor在SuperType原型中 上面例子存在一个问题： 构造函数SuperType的实例作为构造函数SubType的原型使用，这样所有的SubType构造函数的实例都将共享同一个原型！ 在创建子类型的实例时，无法向超类型的构造函数传参 伪造对象继承123456789101112function SuperType() &#123; this.colors = ["red", "blue", "green"]&#125;function SubType() &#123; //继承了 SuperType SuperType.call(this)&#125;var instance1 = new SubType()instance1.colors.push("black")alert(instance1.colors); //"red,blue,green,black"var instance2 = new SubType()alert(instance2.colors); //"red,blue,green" 优点可以传递参数给超类型构造函数 缺点函数无法复用，超类型的原型对子类型不可见 组合继承123456789101112131415161718192021222324252627function SuperType(name)&#123; this.name = name this.colors = ["red", "blue", "green"]&#125;SuperType.prototype.sayName = function()&#123; alert(this.name)&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name) this.age = age&#125;//继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SubTypeSubType.prototype.sayAge = function()&#123; alert(this.age)&#125;var instance1 = new SubType("Nicholas", 29)instance1.colors.push("black")alert(instance1.colors) //"red,blue,green,black"instance1.sayName() //"Nicholas";instance1.sayAge() //29var instance2 = new SubType("Greg", 27)alert(instance2.colors) //"red,blue,green"instance2.sayName() //"Greg";instance2.sayAge() //27 最常用的继承，规避了之前的缺陷，融合之前继承的优点 不足是无论什么情况调用两次超类型构造函数 原型式继承 有时可以不必借助超类型去创建实例作为子类型的原型 直接用对象实例作为某一构造函数的原型，不必创建自定义类型 12345678910111213141516function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" object函数返回值为传入对象o的浅赋值，其中的引用类型值被共享 ECMAScript5的object.creat()方法规范了继承，支持IE9+ 123456var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 寄生式继承 在原型式继承基础上，外面包装一层函数类似工厂模式，在内部以某种方式增强对象 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function createAnother(original)&#123; var clone = object(original) //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi") &#125; return clone //返回这个对象&#125; object并不是必要的，任何有返回新对象的函数都行 寄生组合式继承 通过原型式继承获取超类型的原型副本，再将子类型的原型指向其副本，外面用函数封装传入超类型和子类型构造函数 12345678910function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 这样可以做到只调用一次超类型构造函数 避免了超类构造函数在子类型原型上创建多余属性 原型链保持不变，instanceof和isPrototypeOf()正常使用 寄生组合继承优于组合继承，是引用类型最理想的继承范式 ​ 未完待续… 有待补充]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[联系方式 手机：+86-17501664533 Email：WWWNetizen@163.com 微信号：17501664533 个人信息 孙某某/男/1995 本科/材料成型及控制工程 工作年限：1年 期望职位：Web前端开发 期望城市：上海 语言能力：CET-4 技能清单 熟悉 HTML5/CSS3/Javascript/jQuery/Zepto.js/LeSS 原生Ajax或JQuery的Ajax对象实现后端数据调用，实现前端渲染 常用的跨域问题，JSONP,设置响应头信息，代理 不同终端的屏幕适配，运用Bootstrap框架等方法实现响应式布局 常见的性能优化及兼容问题，熟悉W3C标准 了解 PHP/Node.js 遵循MVC编写简单的后台项目 前端框架：Bootstrap/Vue 后端框架：了解Express 前端构建工具：Gulp/WebPack 数据库相关：MySQL/PDO 管理工具：Git/npm 模块化规范：AMD/CommonJS]]></content>
      <tags>
        <tag>信息 置顶</tag>
      </tags>
  </entry>
</search>

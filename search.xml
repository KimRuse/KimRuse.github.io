<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript继承]]></title>
    <url>%2F2019%2F05%2F16%2Fjs%2F</url>
    <content type="text"><![CDATA[JavaScript 继承两种继承方式，Javascript仅支持其一： 接口继承 – 方法签名 12345678910111213141516//PHP中的接口继承interface InterA &#123; const TITLE = "PHP接口继承"; public function showInfo($a, $b);&#125;interface InterB &#123; public static function readMe();&#125;class Student implements InterA,InterB &#123; public function showInfo($name, $age) &#123; echo "&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;"; &#125; public static function readMe()&#123; echo self::TITLE; &#125;&#125; 实现继承 – 实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承 ECMAScript中只支持实现继承，继承方式主要依赖原型链 1234567891011121314151617function SuperType() &#123; this.property = true&#125;function SubType() &#123; this.subproperty = false&#125;//向SuperType构造函数的 prototype原型中添加方法属性SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;//SubType构造函数的 prototype原型指针 指向 SuperType类型的实例SubType.prototype = new SuperType()SubType.prototype.getSubValue = function() &#123; return this.subproperty&#125;var instance.getSuperValue()alert(instance.getSuperValue()) //true 上例中，SubType构造函数的prototype原型被重写指向SuperType构造函数的一个实例，其中之前SubType构造函数原型中的默认constructor属性被重写，instance.constructor在SuperType原型中 上面例子存在一个问题： 构造函数SuperType的实例作为构造函数SubType的原型使用，这样所有的SubType构造函数的实例都将共享同一个原型！ 在创建子类型的实例时，无法向超类型的构造函数传参 伪造对象继承123456789101112function SuperType() &#123; this.colors = ["red", "blue", "green"]&#125;function SubType() &#123; //继承了 SuperType SuperType.call(this)&#125;var instance1 = new SubType()instance1.colors.push("black")alert(instance1.colors); //"red,blue,green,black"var instance2 = new SubType()alert(instance2.colors); //"red,blue,green" 优点可以传递参数给超类型构造函数 缺点函数无法复用，超类型的原型对子类型不可见 组合继承123456789101112131415161718192021222324252627function SuperType(name)&#123; this.name = name this.colors = ["red", "blue", "green"]&#125;SuperType.prototype.sayName = function()&#123; alert(this.name)&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name) this.age = age&#125;//继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SubTypeSubType.prototype.sayAge = function()&#123; alert(this.age)&#125;var instance1 = new SubType("Nicholas", 29)instance1.colors.push("black")alert(instance1.colors) //"red,blue,green,black"instance1.sayName() //"Nicholas";instance1.sayAge() //29var instance2 = new SubType("Greg", 27)alert(instance2.colors) //"red,blue,green"instance2.sayName() //"Greg";instance2.sayAge() //27 最常用的继承，规避了之前的缺陷，融合之前继承的优点 不足是无论什么情况调用两次超类型构造函数 原型式继承 有时可以不必借助超类型去创建实例作为子类型的原型 直接用对象实例作为某一构造函数的原型，不必创建自定义类型 12345678910111213141516function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" object函数返回值为传入对象o的浅赋值，其中的引用类型值被共享 ECMAScript5的object.creat()方法规范了继承，支持IE9+ 123456var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 寄生式继承 在原型式继承基础上，外面包装一层函数类似工厂模式，在内部以某种方式增强对象 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function createAnother(original)&#123; var clone = object(original) //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi") &#125; return clone //返回这个对象&#125; object并不是必要的，任何有返回新对象的函数都行 寄生组合式继承 通过原型式继承获取超类型的原型副本，再将子类型的原型指向其副本，外面用函数封装传入超类型和子类型构造函数 12345678910function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 这样可以做到只调用一次超类型构造函数 避免了超类构造函数在子类型原型上创建多余属性 原型链保持不变，instanceof和isPrototypeOf()正常使用 寄生组合继承优于组合继承，是引用类型最理想的继承范式 ​ 未完待续… 有待补充]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 数据结构与算法]]></title>
    <url>%2F2019%2F05%2F07%2FJavascript%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript 数据结构与算法数组创建和初始化数组12345var arrs = new Array();//初始化一个数组，长度为 0var arrs = new Array(3);//初始化并指定长度为 3var arrs = new Array('one', 'two', 'three');//初始化并将数组元素作为参数传递给它的构造函数var arrs = [];//初始化一个数组，长度为 0var arrs = ['one', 'two', 'three']; 数组操作方法 添加元素 末尾添加元素 123var numbers = [0,1,2,3,4,5,6];numbers[numbers.length] = 7;numbers.push(7); //push方法 首位添加元素 12345for (var i=numbers.length; i&gt;=0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;numbers.unshift(-2) //unshift方法 删除元素 末尾删除元素 12numbers.length = numbers.length - 1;numbers.pop() //pop方法 首位删除元素1234for (var i=0; i&lt;numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;numbers.shift() //shift()方法 在任意位置添加或删除元素 123numbers.splice(5, 3)// 索引 5 开始的 3 个元素删除numbers.splice(5, 0, 2, 3)// 索引 5 开始的 0 个元素删除，并添加元素 2 和 3numbers.splice(5, 3, 2, 3)// 索引 5 开始的 3 个元素删除，并添加元素 2 和 3 Javascript的数组方法 合并 12345var zero = 0;var one = [1,2,3];var tree = &#123;is: 'tree'&#125;;var four = &#123;-3,-2,-1&#125;;var numbers = four.concat(zero,tree,one) //concat方法可以向一个数组传递数组、对象或元素。按传入的参数顺序连接新数组，结果[-3,-2,-1,0,&#123;is:'tree'&#125;,1,2,3] 迭代 1234567891011121314var isEven = function (x) &#123; return (x % 2 == 0)&#125;var numbers = [1,2,3,4,5,6,7,8,9,10,11,12]numbers.every(isEven) //函数对每一项都返回ture，则返回true，否则falsenumbers.some(isEven) //函数对至少一项返回ture，则返回true，否则falsenumbers.forEach(function(item, index, array) &#123; //要执行的操作&#125;) //没有返回值var myMap = numbers.map(isEven) //函数对每一项的返回结果，作为数组返回var evenNumbers = numbers.filter(isEven) //函数对返回项为ture的值，作为数组返回numbers.reduce(function(previous, current, array) &#123; return //表达式 ， 例如： previous + current&#125;) // 函数返回被叠加到累加器的值，停止返回累加器 ES6中的数组新功能 12345678910111213141516171819202122232425262728293031323334353637//访问@@iterator属性，通过Symbol.iterator访问let iterator = number[Symbol.iterator]()console.log(iterator.next().value) // 1console.log(iterator.next().value) // 2console.log(iterator.next().value) // 3 迭代完返回 undefined//方法entries 返回包含键值对的@@iteratorlet aEntries = numbers.entries()console.log(iterator.next().value) // [0,1]console.log(iterator.next().value) // [1,2]console.log(iterator.next().value) // [2,3] 迭代完返回 undefined//方法keys 返回包含数组索引的@@iteratorlet aKeys = numbers.keys()console.log(iterator.next()) // &#123;value: 0, done: false&#125;console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125; //迭代完，返回&#123;value: undefined, done: true&#125;//方法values 返回包含数组值得@@iteratorlet aValues = numbers.values()console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125;console.log(iterator.next()) // &#123;value: 3, done: false&#125; 迭代完，返回&#123;value: undefined, done: true&#125;//--------------------------------------------------//方法from 根据已有的数组 复制一个数组let numbers2 = Array.from(numbers)//可传入一个过滤值的函数let evens = Array.from(numbers, x =&gt; (x % 2 == 0))//方法of 根据传入参数创建一个数组let numbersCopy = Array.of(...numbers2)//方法fill 填充数组numbers.fill(0) //数组所有值 变为0numbers.fill(2, 1) //数组从索引 1 开始后面变为 2numbers。fill(2 ,3 , 5) //数组从索引 3 开始到 5（不包含）变为2let arr = Array(6).fill(1) // 初始化数组长度6， 全为 1//方法copyWithin 用自身元素 替换 自身元素let arr = [1,2,3,4,5,6]arr.copyWithin(0, 3) // 将索引3 位置及之后元素 替换到 索引0 位置及到索引3 位置之前arr.copyWithin(1, 3, 5) // 将索引3 位置到索引5之前 替换到 索引1 位置及到索引3 位置之前 未完待续]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[联系方式 手机：+86-17501664533 Email：WWWNetizen@163.com 微信号：17501664533 个人信息 孙某某/男/1995 本科/材料成型及控制工程 工作年限：1年 期望职位：Web前端开发 期望城市：上海 语言能力：CET-4 技能清单 熟悉 HTML5/CSS3/Javascript/jQuery/Zepto.js/LeSS 原生Ajax或JQuery的Ajax对象实现后端数据调用，实现前端渲染 常用的跨域问题，JSONP,设置响应头信息，代理 不同终端的屏幕适配，运用Bootstrap框架等方法实现响应式布局 常见的性能优化及兼容问题，熟悉W3C标准 了解 PHP/Node.js 遵循MVC编写简单的后台项目 前端框架：Bootstrap/Vue 后端框架：了解Express 前端构建工具：Gulp/WebPack 数据库相关：MySQL/PDO 管理工具：Git/npm 模块化规范：AMD/CommonJS]]></content>
      <tags>
        <tag>信息 置顶</tag>
      </tags>
  </entry>
</search>

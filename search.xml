<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[游览器缓存]]></title>
    <url>%2F2020%2F01%2F07%2F%E6%B8%B8%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[游览器缓存游览器缓存有四个方面： Memory Cache Service Worker Cache HTTP Cache (Memory Cache and Disk Cache) Push Cache 以上按照资源的优先级排列 HTTP 缓存机制 HTTP缓存分为强缓存和协商缓存，前者优先级高于后者。缓存根据存放位置不同分为，Memory Cache（内存） 和 Disk Cache（硬盘） 强缓存 Header属性Expires、Cache-Control、Pragma 控制强缓存，优先级从左依次升高 Expires的值是一个HTTP日期，与系统时间比较判断缓存效期 Expires依赖客户端时间，可能破坏预期 Expires作为向下兼容方案。Cache-Control是完全替代方案 Cache-Control 控制缓存public和private资源，不缓存no-store，不走强缓存no-cahce 代理服务器缓存public资源，通过s-maxage设置仅在代理服务器生效 默认缓存private，仅当设置s-maxage时变更为public 协商缓存 Header属性 Last-Modified/If-Modified-Since 和 ETag/If-None-Match 控制协商缓存，优先级从左依次升高 Last-Modified 首次请求返回，包含返回资源最后一次修改时间戳 If-Modified-Since 非首次请求，用于比对服务器资源上最后一次修改时间 时间一致 返回304响应，不一致 添加新Last-Modified值 ​ 使用 Last-Modified存在一些弊端，其中多见于以下两点： 编辑文件，文件内容没变，缓存未命中 最小时间计量为1秒，以为小于1秒的改动无法感知，缓存命中 ETag 的值是基于资源内容编码，生成资源唯一标识，首次请求返回 If-None-Match 非首次请求，用于比对服务器资源内容编码是否一致 ETag 比 Last-Modified 更准确，优先级更高 ​ 使用 ETag 的弊端是影响服务器的性能，需要按情况使用]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript继承]]></title>
    <url>%2F2019%2F05%2F16%2Fjs%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JavaScript 继承两种继承方式，Javascript仅支持其一： 接口继承 – 方法签名 12345678910111213141516//PHP中的接口继承interface InterA &#123; const TITLE = "PHP接口继承"; public function showInfo($a, $b);&#125;interface InterB &#123; public static function readMe();&#125;class Student implements InterA,InterB &#123; public function showInfo($name, $age) &#123; echo "&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;"; &#125; public static function readMe()&#123; echo self::TITLE; &#125;&#125; 实现继承 – 实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承 ECMAScript中只支持实现继承，继承方式主要依赖原型链 1234567891011121314151617function SuperType() &#123; this.property = true&#125;function SubType() &#123; this.subproperty = false&#125;//向SuperType构造函数的 prototype原型中添加方法属性SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;//SubType构造函数的 prototype原型指针 指向 SuperType类型的实例SubType.prototype = new SuperType()SubType.prototype.getSubValue = function() &#123; return this.subproperty&#125;var instance.getSuperValue()alert(instance.getSuperValue()) //true 上例中，SubType构造函数的prototype原型被重写指向SuperType构造函数的一个实例，其中之前SubType构造函数原型中的默认constructor属性被重写，instance.constructor在SuperType原型中 上面例子存在一个问题： 构造函数SuperType的实例作为构造函数SubType的原型使用，这样所有的SubType构造函数的实例都将共享同一个原型！ 在创建子类型的实例时，无法向超类型的构造函数传参 伪造对象继承123456789101112function SuperType() &#123; this.colors = ["red", "blue", "green"]&#125;function SubType() &#123; //继承了 SuperType SuperType.call(this)&#125;var instance1 = new SubType()instance1.colors.push("black")alert(instance1.colors); //"red,blue,green,black"var instance2 = new SubType()alert(instance2.colors); //"red,blue,green" 优点可以传递参数给超类型构造函数 缺点函数无法复用，超类型的原型对子类型不可见 组合继承123456789101112131415161718192021222324252627function SuperType(name)&#123; this.name = name this.colors = ["red", "blue", "green"]&#125;SuperType.prototype.sayName = function()&#123; alert(this.name)&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name) this.age = age&#125;//继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SubTypeSubType.prototype.sayAge = function()&#123; alert(this.age)&#125;var instance1 = new SubType("Nicholas", 29)instance1.colors.push("black")alert(instance1.colors) //"red,blue,green,black"instance1.sayName() //"Nicholas";instance1.sayAge() //29var instance2 = new SubType("Greg", 27)alert(instance2.colors) //"red,blue,green"instance2.sayName() //"Greg";instance2.sayAge() //27 最常用的继承，规避了之前的缺陷，融合之前继承的优点 不足是无论什么情况调用两次超类型构造函数 原型式继承 有时可以不必借助超类型去创建实例作为子类型的原型 直接用对象实例作为某一构造函数的原型，不必创建自定义类型 12345678910111213141516function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" object函数返回值为传入对象o的浅赋值，其中的引用类型值被共享 ECMAScript5的object.creat()方法规范了继承，支持IE9+ 123456var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 寄生式继承 在原型式继承基础上，外面包装一层函数类似工厂模式，在内部以某种方式增强对象 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function createAnother(original)&#123; var clone = object(original) //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi") &#125; return clone //返回这个对象&#125; object并不是必要的，任何有返回新对象的函数都行 寄生组合式继承 通过原型式继承获取超类型的原型副本，再将子类型的原型指向其副本，外面用函数封装传入超类型和子类型构造函数 12345678910function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 这样可以做到只调用一次超类型构造函数 避免了超类构造函数在子类型原型上创建多余属性 原型链保持不变，instanceof和isPrototypeOf()正常使用 寄生组合继承优于组合继承，是引用类型最理想的继承范式 ​ 未完待续… 有待补充]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 数据结构与算法]]></title>
    <url>%2F2019%2F05%2F07%2FJavascript%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript 数据结构与算法数组创建和初始化数组12345var arrs = new Array();//初始化一个数组，长度为 0var arrs = new Array(3);//初始化并指定长度为 3var arrs = new Array('one', 'two', 'three');//初始化并将数组元素作为参数传递给它的构造函数var arrs = [];//初始化一个数组，长度为 0var arrs = ['one', 'two', 'three']; 数组操作方法 添加元素 末尾添加元素 123var numbers = [0,1,2,3,4,5,6];numbers[numbers.length] = 7;numbers.push(7); //push方法 首位添加元素 12345for (var i=numbers.length; i&gt;=0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;numbers.unshift(-2) //unshift方法 删除元素 末尾删除元素 12numbers.length = numbers.length - 1;numbers.pop() //pop方法 首位删除元素1234for (var i=0; i&lt;numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;numbers.shift() //shift()方法 在任意位置添加或删除元素 123numbers.splice(5, 3)// 索引 5 开始的 3 个元素删除numbers.splice(5, 0, 2, 3)// 索引 5 开始的 0 个元素删除，并添加元素 2 和 3numbers.splice(5, 3, 2, 3)// 索引 5 开始的 3 个元素删除，并添加元素 2 和 3 Javascript的数组方法 合并 12345var zero = 0;var one = [1,2,3];var tree = &#123;is: 'tree'&#125;;var four = &#123;-3,-2,-1&#125;;var numbers = four.concat(zero,tree,one) //concat方法可以向一个数组传递数组、对象或元素。按传入的参数顺序连接新数组，结果[-3,-2,-1,0,&#123;is:'tree'&#125;,1,2,3] 迭代 1234567891011121314var isEven = function (x) &#123; return (x % 2 == 0)&#125;var numbers = [1,2,3,4,5,6,7,8,9,10,11,12]numbers.every(isEven) //函数对每一项都返回ture，则返回true，否则falsenumbers.some(isEven) //函数对至少一项返回ture，则返回true，否则falsenumbers.forEach(function(item, index, array) &#123; //要执行的操作&#125;) //没有返回值var myMap = numbers.map(isEven) //函数对每一项的返回结果，作为数组返回var evenNumbers = numbers.filter(isEven) //函数对返回项为ture的值，作为数组返回numbers.reduce(function(previous, current, array) &#123; return //表达式 ， 例如： previous + current&#125;) // 函数返回被叠加到累加器的值，停止返回累加器 ES6中的数组新功能 12345678910111213141516171819202122232425262728293031323334353637//访问@@iterator属性，通过Symbol.iterator访问let iterator = number[Symbol.iterator]()console.log(iterator.next().value) // 1console.log(iterator.next().value) // 2console.log(iterator.next().value) // 3 迭代完返回 undefined//方法entries 返回包含键值对的@@iteratorlet aEntries = numbers.entries()console.log(iterator.next().value) // [0,1]console.log(iterator.next().value) // [1,2]console.log(iterator.next().value) // [2,3] 迭代完返回 undefined//方法keys 返回包含数组索引的@@iteratorlet aKeys = numbers.keys()console.log(iterator.next()) // &#123;value: 0, done: false&#125;console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125; //迭代完，返回&#123;value: undefined, done: true&#125;//方法values 返回包含数组值得@@iteratorlet aValues = numbers.values()console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125;console.log(iterator.next()) // &#123;value: 3, done: false&#125; 迭代完，返回&#123;value: undefined, done: true&#125;//--------------------------------------------------//方法from 根据已有的数组 复制一个数组let numbers2 = Array.from(numbers)//可传入一个过滤值的函数let evens = Array.from(numbers, x =&gt; (x % 2 == 0))//方法of 根据传入参数创建一个数组let numbersCopy = Array.of(...numbers2)//方法fill 填充数组numbers.fill(0) //数组所有值 变为0numbers.fill(2, 1) //数组从索引 1 开始后面变为 2numbers。fill(2 ,3 , 5) //数组从索引 3 开始到 5（不包含）变为2let arr = Array(6).fill(1) // 初始化数组长度6， 全为 1//方法copyWithin 用自身元素 替换 自身元素let arr = [1,2,3,4,5,6]arr.copyWithin(0, 3) // 将索引3 位置及之后元素 替换到 索引0 位置及到索引3 位置之前arr.copyWithin(1, 3, 5) // 将索引3 位置到索引5之前 替换到 索引1 位置及到索引3 位置之前 排序元素 12345678910111213141516171819202122232425262728293031numbers.reverse() // 反序输出数组numbers.sort(function(a, b) &#123;// return a-b; if (a &lt; b ) &#123; return -1; &#125; else if (a &gt; b) &#123; return 1; &#125; else return 0;&#125;) // sort根据返回值的情况排序//----------------------------------//自定义排序var friends = [ &#123;name:'John',age:30&#125;,&#123;name:'Ana',age:20&#125;,&#123;name:'Chris',age:25&#125; ]function cpPerson(a, b) &#123; if (a.age &lt; b.age ) &#123; return -1; &#125; else if (a.age &gt; b.age) &#123; return 1; &#125; else return 0;&#125;friends.sort(cpPerson); // sort对任何对象类型排序//字符串排序var names = ['Ana', 'ana', 'john', 'John']names.sort() // sort根据字符对应的ASCII值来比较// sort传入一个忽略大小写的比较函数function(a, b) &#123; if (a.toLowerCase &lt; b.toLowerCase ) &#123; return -1; &#125; else if (a.toLowerCase &gt; b.toLowerCase) &#123; return 1; &#125; else return 0;&#125; 搜索 123456789101112numbers.indexOf(num) // 返回匹配的第一个元素索引numbers.lastindexOf(num) // 返回匹配的最后一个元素索引//ES6 --- find &amp;&amp; findIndex方法let numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]function mf(elm, index, arr) &#123; return (elm % 13 == 0) ? true : false)&#125;numbers.find(mf) // 返回第一个满足的元素值，没有满足的返回undefinednumbers.findIndex(mf) // 返回第一个满足的元素索引，没有满足的返回 -1//ES7 --- includes方法numbers.includes(num) // 检测数组中是否包含某元素，有true，否则falsenumbers.includes(num, start, end) // 可以设置起始结束范围 数组输出为字符串 1numbers.toString().join('-') // 输出字符串并设置分隔符 类型数组 WebGL API、进行位操作、处理文件和图像时，类型数组用处大1let myArray = new TypedArray(length) // 用于存储单一类型的数据 栈栈的数据结构]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>

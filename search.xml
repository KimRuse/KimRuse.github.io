<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[游览器缓存]]></title>
    <url>%2F2020%2F01%2F07%2F%E6%B8%B8%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[游览器缓存游览器缓存有四个方面： Memory Cache Service Worker Cache HTTP Cache (Memory Cache and Disk Cache) Push Cache 以上按照资源的优先级排列 HTTP 缓存机制 HTTP缓存分为强缓存和协商缓存，前者优先级高于后者。缓存根据存放位置不同分为，Memory Cache（内存） 和 Disk Cache（硬盘） 强缓存 Header属性Expires、Cache-Control、Pragma 控制强缓存，优先级从左依次升高 Expires的值是一个HTTP日期，与系统时间比较判断缓存效期 Expires依赖客户端时间，可能破坏预期 Expires作为向下兼容方案。Cache-Control是完全替代方案 Cache-Control 控制缓存public和private资源，不缓存no-store，不走强缓存no-cahce 代理服务器缓存public资源，通过s-maxage设置仅在代理服务器生效 默认缓存private，仅当设置s-maxage时变更为public 协商缓存 Header属性 Last-Modified/If-Modified-Since 和 ETag/If-None-Match 控制协商缓存，优先级从左依次升高 Last-Modified 首次请求返回，包含返回资源最后一次修改时间戳 If-Modified-Since 非首次请求，用于比对服务器资源上最后一次修改时间 时间一致 返回304响应，不一致 添加新Last-Modified值 ​ 使用 Last-Modified存在一些弊端，其中多见于以下两点： 编辑文件，文件内容没变，缓存未命中 最小时间计量为1秒，以为小于1秒的改动无法感知，缓存命中 ETag 的值是基于资源内容编码，生成资源唯一标识，首次请求返回 If-None-Match 非首次请求，用于比对服务器资源内容编码是否一致 ETag 比 Last-Modified 更准确，优先级更高 ​ 使用 ETag 的弊端是影响服务器的性能，需要按情况使用 HTTP 缓存决策 对于频繁更新的资源，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数 Service Worker Cache Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache Server Worker 对协议是有要求的，必须以 https 协议为前提 Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise A/+ 标准实现]]></title>
    <url>%2F2019%2F05%2F16%2FPromiseA%2B%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84Promise%2F</url>
    <content type="text"><![CDATA[Promise A/+ 标准实现自己的 PromisePromise A/+规范 文档地址 规范中的术语 “promise” 是拥有符合规范的then方法的一个对象或函数 “thenable” 一个定义了then方法的对象或函数 “value” 任意的合法JS值 “reason” 一个指示promise为什么被拒绝的值 “exception” 一个通过throw语句抛出的值 Promise状态一个Promise必须是pending、fulfilled、rejected三种状态之一 pending状态时，可转换为 fulfilled 或 rejected 状态 fulfilled状态时，不能转化其他状态 且 必须包含value，value不能改变 rejected状态时，不能转化其他状态 且 必须包含reason，reason不能改变 ( 不能改变是指，通过===判定相等 即不变，非深层不变 ) 1234567891011121314151617function Promise(exc) &#123; // 这里没有实现隐藏this上的变量 let self = this self.status = 'pending' self.data = void 0 self.onResolvedCallback = [] self.onRejectedCallback = [] function resolve(val) &#123;/**TODO*/&#125; function reject(res) &#123;/**TODO*/&#125; try &#123; exc(resolve.bind(this), reject.bind(this)) &#125; catch(e) &#123; reject(e) &#125;&#125; 接下来实现resolve 和 reject 处理变更后的状态和值，及可能的回调 123456789101112131415161718192021222324252627// ...function resolve(val) &#123; setTimeout(function () &#123; // 异步执行所有的回调函数 if (_this.status === "pending") &#123; _this.status = "resolved"; _this.data = value; for (var i = 0; i &lt; _this.onResolvedCallback.length; i++) &#123; _this.onResolvedCallback[i](value); &#125; &#125; &#125;);&#125;function reject(res) &#123; setTimeout(function () &#123; // 异步执行所有的回调函数 if (_this.status === "pending") &#123; _this.status = "rejected"; _this.data = reason; for (var i = 0; i &lt; _this.onRejectedCallback.length; i++) &#123; _this.onRejectedCallback[i](reason); &#125; &#125; &#125;);&#125;// ... then方法一个promise的then方法接受两个参数 1promise.then(onFulfilled, onRejected) onFulfilled 和 onRejected 为可选参数，当不是function时，必须忽略；pending状态改变时 promise2 的value或reason 必须等于promise1 onFulfilled 和 onRejected 只能被调用一次，并且在promise决议之后调用，使用promise的value或reason作为其第一参数 onFulfilled 和 onRejected 必须在当前执行上下文栈清空后，被异步调用，根据规范提示我们可以用一个”macro-task”实现，如setTimeout，或一个”micro-task” onFulfilled 和 onRejected 返回一个值x, 运行[[Resolve]] (promise,x)，抛出e时，promise2必须rejected(e) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Promise.prototype.then = function (onResolved, onRejected) &#123; var _this = this; var promise2; onResolved = typeof onResolved === "function" ? onResolved : function (val) &#123; return val; &#125;; onRejected = typeof onRejected === "function" ? onRejected : function (res) &#123; throw res; &#125;; if (_this.status === "resolved") &#123; return (promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onResolved try &#123; var x = onResolved(_this.data); resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (_this.status === "rejected") &#123; return (promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(_this.data); resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (_this.status === "pending") &#123; // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义 return (promise2 = new Promise(function (resolve, reject) &#123; _this.onResolvedCallback.push(function (value) &#123; try &#123; var x = onResolved(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); _this.onRejectedCallback.push(function (reason) &#123; try &#123; var x = onRejected(reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;; 接下来resolvePromise处理return值可能为promise的thenable。按照标准实现的promise之间可以交互，未按标准实现的thenable也会被妥当处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function resolvePromise(promise2, x, resolve, reject) &#123; var then; // 2.3.3.3.3 及 2.3.3.3.4 确保resolvePromise、rejectPromise，只有第一个被调用的调用，且有一个被调用，调用then方法中抛出异常的catch被忽略 var thenCalledOrThrow = false; // 防止promise2状态pending静默断链, 2.3.1 if (promise2 === x) &#123; return reject(new TypeError("Chaining cycle detected for promise!")); &#125; if (x instanceof Promise) &#123; if (x.status === "pending") &#123; // 2.3.2.1 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值的 x.then(function (v) &#123; resolvePromise(promise2, v, resolve, reject); &#125;, reject); &#125; else &#123; // 状态非pending 返回resolvePromise处理值作为x的value或reason 2.3.2.2 2.3.2.3 x.then(resolve, reject); &#125; return; &#125; if (x !== null &amp;&amp; (typeof x === "object" || typeof x === "function")) &#123; try &#123; then = x.then; // 因为可能调用一个访问器属性getter 2.3.3.1 2.3.3.2 if (typeof then === "function") &#123; // 2.3.3.3 then.call( x, // resolvePromise function rs(y) &#123; if (thenCalledOrThrow) return; thenCalledOrThrow = true; return resolvePromise(promise2, y, resolve, reject); &#125;, // rejectPromsie function rj(r) &#123; if (thenCalledOrThrow) return; thenCalledOrThrow = true; return reject(r); &#125; ); &#125; else &#123; resolve(x); // 2.3.3.4 &#125; &#125; catch (e) &#123; if (thenCalledOrThrow) return; // 2.3.3.3.4 thenCalledOrThrow = true; return reject(e); &#125; &#125; else &#123; resolve(x); // 2.3.4 &#125;&#125; 接下来可以通过 promises-aplus-tests 测试脚本, 测试下结果]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript继承]]></title>
    <url>%2F2019%2F05%2F16%2Fjs%2F</url>
    <content type="text"><![CDATA[JavaScript 继承两种继承方式，Javascript仅支持其一： 接口继承 – 方法签名 12345678910111213141516//PHP中的接口继承interface InterA &#123; const TITLE = "PHP接口继承"; public function showInfo($a, $b);&#125;interface InterB &#123; public static function readMe();&#125;class Student implements InterA,InterB &#123; public function showInfo($name, $age) &#123; echo "&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;"; &#125; public static function readMe()&#123; echo self::TITLE; &#125;&#125; 实现继承 – 实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承 ECMAScript中只支持实现继承，继承方式主要依赖原型链 1234567891011121314151617function SuperType() &#123; this.property = true&#125;function SubType() &#123; this.subproperty = false&#125;//向SuperType构造函数的 prototype原型中添加方法属性SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;//SubType构造函数的 prototype原型指针 指向 SuperType类型的实例SubType.prototype = new SuperType()SubType.prototype.getSubValue = function() &#123; return this.subproperty&#125;var instance.getSuperValue()alert(instance.getSuperValue()) //true 上例中，SubType构造函数的prototype原型被重写指向SuperType构造函数的一个实例，其中之前SubType构造函数原型中的默认constructor属性被重写，instance.constructor在SuperType原型中 上面例子存在一个问题： 构造函数SuperType的实例作为构造函数SubType的原型使用，这样所有的SubType构造函数的实例都将共享同一个原型！ 在创建子类型的实例时，无法向超类型的构造函数传参 伪造对象继承123456789101112function SuperType() &#123; this.colors = ["red", "blue", "green"]&#125;function SubType() &#123; //继承了 SuperType SuperType.call(this)&#125;var instance1 = new SubType()instance1.colors.push("black")alert(instance1.colors); //"red,blue,green,black"var instance2 = new SubType()alert(instance2.colors); //"red,blue,green" 优点可以传递参数给超类型构造函数 缺点函数无法复用，超类型的原型对子类型不可见 组合继承123456789101112131415161718192021222324252627function SuperType(name)&#123; this.name = name this.colors = ["red", "blue", "green"]&#125;SuperType.prototype.sayName = function()&#123; alert(this.name)&#125;;function SubType(name, age)&#123; //继承属性 SuperType.call(this, name) this.age = age&#125;//继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SubTypeSubType.prototype.sayAge = function()&#123; alert(this.age)&#125;var instance1 = new SubType("Nicholas", 29)instance1.colors.push("black")alert(instance1.colors) //"red,blue,green,black"instance1.sayName() //"Nicholas";instance1.sayAge() //29var instance2 = new SubType("Greg", 27)alert(instance2.colors) //"red,blue,green"instance2.sayName() //"Greg";instance2.sayAge() //27 最常用的继承，规避了之前的缺陷，融合之前继承的优点 不足是无论什么情况调用两次超类型构造函数 原型式继承 有时可以不必借助超类型去创建实例作为子类型的原型 直接用对象实例作为某一构造函数的原型，不必创建自定义类型 12345678910111213141516function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" object函数返回值为传入对象o的浅赋值，其中的引用类型值被共享 ECMAScript5的object.creat()方法规范了继承，支持IE9+ 123456var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 寄生式继承 在原型式继承基础上，外面包装一层函数类似工厂模式，在内部以某种方式增强对象 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function createAnother(original)&#123; var clone = object(original) //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi") &#125; return clone //返回这个对象&#125; object并不是必要的，任何有返回新对象的函数都行 寄生组合式继承 通过原型式继承获取超类型的原型副本，再将子类型的原型指向其副本，外面用函数封装传入超类型和子类型构造函数 12345678910function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; 这样可以做到只调用一次超类型构造函数 避免了超类构造函数在子类型原型上创建多余属性 原型链保持不变，instanceof和isPrototypeOf()正常使用 寄生组合继承优于组合继承，是引用类型最理想的继承范式 ​ 未完待续… 有待补充]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 数据结构与算法]]></title>
    <url>%2F2019%2F05%2F07%2FJavascript%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript 数据结构与算法数组创建和初始化数组12345var arrs = new Array();//初始化一个数组，长度为 0var arrs = new Array(3);//初始化并指定长度为 3var arrs = new Array('one', 'two', 'three');//初始化并将数组元素作为参数传递给它的构造函数var arrs = [];//初始化一个数组，长度为 0var arrs = ['one', 'two', 'three']; 数组操作方法 添加元素 末尾添加元素 123var numbers = [0,1,2,3,4,5,6];numbers[numbers.length] = 7;numbers.push(7); //push方法 首位添加元素 12345for (var i=numbers.length; i&gt;=0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;numbers.unshift(-2) //unshift方法 删除元素 末尾删除元素 12numbers.length = numbers.length - 1;numbers.pop() //pop方法 首位删除元素1234for (var i=0; i&lt;numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;numbers.shift() //shift()方法 在任意位置添加或删除元素 123numbers.splice(5, 3)// 索引 5 开始的 3 个元素删除numbers.splice(5, 0, 2, 3)// 索引 5 开始的 0 个元素删除，并添加元素 2 和 3numbers.splice(5, 3, 2, 3)// 索引 5 开始的 3 个元素删除，并添加元素 2 和 3 Javascript的数组方法 合并 12345var zero = 0;var one = [1,2,3];var tree = &#123;is: 'tree'&#125;;var four = &#123;-3,-2,-1&#125;;var numbers = four.concat(zero,tree,one) //concat方法可以向一个数组传递数组、对象或元素。按传入的参数顺序连接新数组，结果[-3,-2,-1,0,&#123;is:'tree'&#125;,1,2,3] 迭代 1234567891011121314var isEven = function (x) &#123; return (x % 2 == 0)&#125;var numbers = [1,2,3,4,5,6,7,8,9,10,11,12]numbers.every(isEven) //函数对每一项都返回ture，则返回true，否则falsenumbers.some(isEven) //函数对至少一项返回ture，则返回true，否则falsenumbers.forEach(function(item, index, array) &#123; //要执行的操作&#125;) //没有返回值var myMap = numbers.map(isEven) //函数对每一项的返回结果，作为数组返回var evenNumbers = numbers.filter(isEven) //函数对返回项为ture的值，作为数组返回numbers.reduce(function(previous, current, array) &#123; return //表达式 ， 例如： previous + current&#125;) // 函数返回被叠加到累加器的值，停止返回累加器 ES6中的数组新功能 12345678910111213141516171819202122232425262728293031323334353637//访问@@iterator属性，通过Symbol.iterator访问let iterator = number[Symbol.iterator]()console.log(iterator.next().value) // 1console.log(iterator.next().value) // 2console.log(iterator.next().value) // 3 迭代完返回 undefined//方法entries 返回包含键值对的@@iteratorlet aEntries = numbers.entries()console.log(iterator.next().value) // [0,1]console.log(iterator.next().value) // [1,2]console.log(iterator.next().value) // [2,3] 迭代完返回 undefined//方法keys 返回包含数组索引的@@iteratorlet aKeys = numbers.keys()console.log(iterator.next()) // &#123;value: 0, done: false&#125;console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125; //迭代完，返回&#123;value: undefined, done: true&#125;//方法values 返回包含数组值得@@iteratorlet aValues = numbers.values()console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125;console.log(iterator.next()) // &#123;value: 3, done: false&#125; 迭代完，返回&#123;value: undefined, done: true&#125;//--------------------------------------------------//方法from 根据已有的数组 复制一个数组let numbers2 = Array.from(numbers)//可传入一个过滤值的函数let evens = Array.from(numbers, x =&gt; (x % 2 == 0))//方法of 根据传入参数创建一个数组let numbersCopy = Array.of(...numbers2)//方法fill 填充数组numbers.fill(0) //数组所有值 变为0numbers.fill(2, 1) //数组从索引 1 开始后面变为 2numbers。fill(2 ,3 , 5) //数组从索引 3 开始到 5（不包含）变为2let arr = Array(6).fill(1) // 初始化数组长度6， 全为 1//方法copyWithin 用自身元素 替换 自身元素let arr = [1,2,3,4,5,6]arr.copyWithin(0, 3) // 将索引3 位置及之后元素 替换到 索引0 位置及到索引3 位置之前arr.copyWithin(1, 3, 5) // 将索引3 位置到索引5之前 替换到 索引1 位置及到索引3 位置之前 排序元素 12345678910111213141516171819202122232425262728293031numbers.reverse() // 反序输出数组numbers.sort(function(a, b) &#123;// return a-b; if (a &lt; b ) &#123; return -1; &#125; else if (a &gt; b) &#123; return 1; &#125; else return 0;&#125;) // sort根据返回值的情况排序//----------------------------------//自定义排序var friends = [ &#123;name:'John',age:30&#125;,&#123;name:'Ana',age:20&#125;,&#123;name:'Chris',age:25&#125; ]function cpPerson(a, b) &#123; if (a.age &lt; b.age ) &#123; return -1; &#125; else if (a.age &gt; b.age) &#123; return 1; &#125; else return 0;&#125;friends.sort(cpPerson); // sort对任何对象类型排序//字符串排序var names = ['Ana', 'ana', 'john', 'John']names.sort() // sort根据字符对应的ASCII值来比较// sort传入一个忽略大小写的比较函数function(a, b) &#123; if (a.toLowerCase &lt; b.toLowerCase ) &#123; return -1; &#125; else if (a.toLowerCase &gt; b.toLowerCase) &#123; return 1; &#125; else return 0;&#125; 搜索 123456789101112numbers.indexOf(num) // 返回匹配的第一个元素索引numbers.lastindexOf(num) // 返回匹配的最后一个元素索引//ES6 --- find &amp;&amp; findIndex方法let numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]function mf(elm, index, arr) &#123; return (elm % 13 == 0) ? true : false)&#125;numbers.find(mf) // 返回第一个满足的元素值，没有满足的返回undefinednumbers.findIndex(mf) // 返回第一个满足的元素索引，没有满足的返回 -1//ES7 --- includes方法numbers.includes(num) // 检测数组中是否包含某元素，有true，否则falsenumbers.includes(num, start, end) // 可以设置起始结束范围 数组输出为字符串 1numbers.toString().join('-') // 输出字符串并设置分隔符 类型数组 WebGL API、进行位操作、处理文件和图像时，类型数组用处大1let myArray = new TypedArray(length) // 用于存储单一类型的数据 栈栈的数据结构]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
